#define  _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <math.h>

//题型一、定义一维数组

//int main()//选择法
//{
//	int a[10];// 定义一个大小为10的整数数组a用于存储输入的10个面积值
//	int i, j, t; // 定义三个辅助变量i、j和t，其中t用于交换数组元素
//	printf("请输入10个面积\n");// 提示用户输入面积
//	for (i = 0; i <= 9; i++)// 用循环读取并存储10个面积
//
//	{
//		scanf("%d", &a[i]);
//	}  
//	for(i=0;i<=8;i++)// 外层循环控制比较轮数，共需比较9轮
//	{
//		for (j = i + 1; j <= 9; j++)
//		{
//			if (a[i] > a[j])
//			{
//				t = a[i];
//				a[i] = a[j];
//				a[j] = t;
//			}
//		}
//	}
//	printf("排序后的面积依次是:\n");// 输出排序结果
//	for (i = 0; i <= 9; i++)// 遍历数组并打印每个元素
//	{
//		printf("%d\t", a[i]);
//	}
//	printf("\n"); // 打印换行符
//	return 0;
//}

//int main()//冒泡法（沉底法）
//{
//	printf("输入的十个面积是\n");// 提示用户即将输入十个面积
//	int a[10];// 定义一个大小为10的整数数组a用于存储输入的面积值
//	int i, j, t, v;// 定义四个辅助变量i、j、t和v，其中t用于交换数组元素，v用于控制排序轮数
//	for (i = 0; i <= 9; i++)// 用循环读取并存储10个面积
//	{
//		scanf("%d", &a[i]);
//	}
//	for(v=0;v<=8;v++) // 外层循环控制比较轮数，共需比较9轮
//	{
//		for (i = 0; i <= 8; i++) // 内层循环逐次比较相邻的元素，随着每轮结束，最大的元素会逐渐“浮”到数组末尾，因此后续轮数无需再考虑已排序的部分
//		{
//			j = i + 1;// 每轮内层循环开始时，设置j为当前元素的下一个位置
//			if (a[i] > a[j]) // 如果前一个元素大于后一个元素，则交换它们的位置
//			{
//				t = a[i];
//				a[i] = a[j];
//				a[j] = t;
//			}
//		}
//	}
//	printf("排序后的面积大小为\n");// 输出提示信息
//	for (i = 0; i <= 9; i++)// 遍历数组并打印每个元素
//	{
//		printf("%d\t", a[i]);// 输出每个排序后的面积值
//	}
//	printf("\n");// 打印换行符
//	return 0;
//}

//题型二、定义二维数组

//int main()
//{
//	int a[2][3] = { {1,2,3},{4,5,6} };
//	int b[3][2];
//	int i, j;
//	for (i = 0; i <= 2; i++);
//	{
//		for (j = 0; j <= 2; j++);
//		b[j][i] = a[i][j];
//	}
//	printf("二维数组b为\n");
//	for (j = 0; j <= 2; j++)
//	{
//		for(i=0;i<=3;i==)
//
//	}
//	return 0;
//}

//int main()/*本题的问题为输出矩阵a[3][3]中的最大值*/
//{
//	int a[3][3] = { {1,2,3} ,{9,8,7},{-10,10,-5} };
//	int t;
//	for (int i = 0; i <= 2; i++)
//	{
//		for (int j = 0; j <= 1; j++)
//		{
//			if(a[i][j]>=a[i][j+1])
//			{
//				t = a[i][j + 1];
//				a[i][j + 1] = a[i][j];
//				a[i][j] = t;
//			}
//		}
//	}
//	int MAX = a[2][2];
//	printf("该矩阵中值最大的数是%d\n",MAX);
//	return 0;
//}
//AI人工智能修正后的代码应该如下所示：
//
//C
//int main()
//{
//    int a[3][3] = { {1,2,3}, {9,8,7}, {-10,10,-5} };
//    int t;
//
//    for (int i = 0; i < 3; i++)
//    {
//        for (int j = 0; j < 2; j++)
//        {
//            if (a[i][j] >= a[i][j + 1])
//            {
//                t = a[i][j + 1];
//                a[i][j + 1] = a[i][j];
//                a[i][j] = t;
//            }
//        }
//    }
//找到整个矩阵中的最大值
///*??在后来的代码中为何还要将a[i][j]与max_value作比较，
//* 在前半部分的代码中已经将该矩阵中最大的数换到了a[2][2]
//* 而在后半部分代码中直接将，max_value与a[][]各项做了比较并与大的数
//* 发生替换，因此本就可以当作另一种解题方法，无需再进行后半部分代码
//* 直接输出max即可*/
//    int max_value = a[0][0];
//    for (int i = 0; i < 3; i++)
//    {
//        for (int j = 0; j < 3; j++)
//        {
//            if (a[i][j] > max_value)
//            {
//                max_value = a[i][j];
//            }
//        }
//    }
//
//    printf("该矩阵中值最大的数是%d\n", max_value);
//    return 0;
//}
/*对于取一个数组中的最大值，较为方便的方法应该为AI修改过后的代码中
的后半部分，通过引入一个值，将其与所有数进行比较，再与大于其的数
交换大小，从而做到最后输出时该值成为所有数中的最大值。*/

